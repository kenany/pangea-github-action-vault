import { Signer } from "./utils/signer.js";
/**
 * PangeaConfig options
 */
export interface ConfigOptions {
    domain?: string;
    environment?: ConfigEnv;
    configID?: string;
    insecure?: boolean;
    requestRetries?: number;
    requestTimeout?: number;
    queuedRetryEnabled?: boolean;
    pollResultTimeoutMs?: number;
    queuedRetries?: number;
    customUserAgent?: string;
}
export interface PostOptions {
    pollResultSync?: boolean;
}
export declare enum ConfigEnv {
    LOCAL = "local",
    PRODUCTION = "production"
}
export interface Dictionary {
    [key: string]: string | boolean | number | Dictionary;
}
/**
 * Secure Audit interface definitions
 */
export declare namespace Audit {
    interface LogOptions {
        verbose?: boolean;
        signer?: Signer;
        skipEventVerification?: boolean;
        verify?: boolean;
        publicKeyInfo?: Object;
    }
    interface LogData {
        event: Audit.Event;
        verbose?: boolean;
        signature?: string;
        public_key?: string;
        prev_root?: string;
    }
    interface Event {
        [key: string]: Object | string | boolean | number | Date;
    }
    interface EventEnvelope {
        event: Event;
        signature?: string;
        public_key?: string;
        received_at: string;
    }
    interface AuditRecord {
        envelope: Audit.EventEnvelope;
        hash: string;
        membership_proof?: string;
        published?: boolean;
        leaf_index?: string;
        consistency_verification?: string;
        membership_verification?: string;
        signature_verification?: string;
    }
    interface Root {
        url?: string;
        published_at?: string;
        size: number;
        root_hash: string;
        consistency_proof: string[];
        tree_name: string;
    }
    interface LogResponse {
        hash: string;
        envelope: Audit.EventEnvelope;
        unpublished_root?: string;
        membership_proof?: string;
        consistency_proof?: string[];
        consistency_verification?: string;
        membership_verification?: string;
        signature_verification?: string;
    }
    interface SearchOptions {
        verifyConsistency?: boolean;
        skipEventVerification?: boolean;
    }
    interface SearchResponse {
        id: string;
        expires_at: string;
        count: number;
        events: Audit.AuditRecord[];
        root?: Root;
        unpublished_root?: Root;
    }
    interface SearchRestriction {
        actor?: Array<string>;
        action?: Array<string>;
        source?: Array<string>;
        status?: Array<string>;
        target?: Array<string>;
    }
    interface SearchParamsOptions {
        limit?: number;
        max_results?: number;
        start?: string;
        end?: string;
        order?: string;
        order_by?: string;
        search_restriction?: Audit.SearchRestriction;
        verbose?: boolean;
    }
    interface SearchParams extends SearchParamsOptions {
        query: string;
    }
    interface RootParams {
        tree_size?: number;
    }
    interface ResultResponse {
        events: AuditRecord[];
        count: number;
        root?: Root;
    }
    interface RootRequest {
        tree_size?: number;
    }
    interface RootResult extends Root {
        data: Root;
    }
}
export declare namespace Redact {
    interface TextResult {
        redacted_text?: string;
        count: number;
    }
    interface StructuredResult {
        redacted_data?: object;
        count: number;
    }
    interface Options {
        debug?: boolean;
        rules?: string[];
        return_result?: boolean;
    }
    interface TextOptions extends Options {
    }
    interface StructuredOptions extends Options {
        jsonp?: string[];
        format?: string;
    }
    interface TextParams extends TextOptions {
        text: string;
    }
    interface StructuredParams extends StructuredOptions {
        data: Object;
    }
}
export declare namespace Embargo {
    interface Sanction {
        list_name: string;
        embargoed_country_name: string;
        embargoed_country_iso_code: string;
        issuing_country: string;
        annotations: object;
    }
    interface CheckResult {
        sanctions: Sanction[];
    }
}
/**
 * Intel services interface definitions
 */
export declare namespace Intel {
    enum HashType {
        SHA256 = "sha256",
        SHA1 = "sha1",
        MD5 = "md5"
    }
    interface Options {
        verbose?: boolean;
        raw?: boolean;
        provider?: string;
    }
    interface ReputationResult extends CommonResult {
        data: {
            category: string[];
            score: number;
            verdict: string;
        };
    }
    namespace File {
        interface Options extends Intel.Options {
        }
        interface Params {
            hash: string;
            hash_type: string;
        }
        export interface ReputationOptions extends Options {
        }
        export interface ReputationResult extends Intel.ReputationResult {
        }
        export interface ReputationRequest extends Params, ReputationOptions {
        }
        export {};
    }
    namespace Domain {
        interface Options extends Intel.Options {
        }
        interface Params {
            domain: string;
        }
        export interface ReputationOptions extends Options {
        }
        export interface ReputationResult extends Intel.ReputationResult {
        }
        export interface ReputationRequest extends Params, ReputationOptions {
        }
        export {};
    }
    namespace URL {
        interface Options extends Intel.Options {
        }
        interface Params {
            url: string;
        }
        export interface ReputationOptions extends Options {
        }
        export interface ReputationResult extends Intel.ReputationResult {
        }
        export interface ReputationRequest extends Params, ReputationOptions {
        }
        export {};
    }
    namespace IP {
        interface Options extends Intel.Options {
        }
        interface Params {
            ip: string;
        }
        export interface GeolocateOptions extends Options {
        }
        export interface GeolocateRequest extends Params, GeolocateOptions {
        }
        export interface DomainOptions extends Options {
        }
        export interface DomainRequest extends Params, DomainOptions {
        }
        export interface VPNOptions extends Options {
        }
        export interface VPNRequest extends Params, VPNOptions {
        }
        export interface ProxyOptions extends Options {
        }
        export interface ProxyRequest extends Params, ProxyOptions {
        }
        export interface ReputationOptions extends Options {
        }
        export interface ReputationResult extends Intel.ReputationResult {
        }
        export interface ReputationParams extends Params, ReputationOptions {
        }
        export interface GeolocateResult extends CommonResult {
            data: {
                country: string;
                city: string;
                latitude: number;
                longitude: number;
                postal_code: string;
                country_code: string;
            };
        }
        export interface DomainResult extends CommonResult {
            data: {
                domain_found: boolean;
                domain?: string;
            };
        }
        export interface VPNResult extends CommonResult {
            data: {
                is_vpn: boolean;
            };
        }
        export interface ProxyResult extends CommonResult {
            data: {
                is_proxy: boolean;
            };
        }
        export {};
    }
    interface CommonResult {
        parameter?: Dictionary;
        raw_data?: Dictionary;
    }
    namespace User {
        interface BreachedData {
            found_in_breach: boolean;
            breach_count: number;
        }
        interface BreachedResult extends Intel.CommonResult {
            data: BreachedData;
        }
        namespace User {
            interface BreachedOptions extends Intel.Options {
                start?: string;
                end?: string;
            }
            interface BreachedEmailRequest extends BreachedOptions {
                email: string;
            }
            interface BreachedUsernameRequest extends BreachedOptions {
                username: string;
            }
            interface BreachedIPRequest extends BreachedOptions {
                ip: string;
            }
            interface BreachedPhoneRequest extends BreachedOptions {
                phone_number: string;
            }
            interface BreachedResult extends Intel.User.BreachedResult {
            }
            type BreachedRequest = BreachedEmailRequest | BreachedIPRequest | BreachedPhoneRequest | BreachedUsernameRequest;
        }
        namespace Password {
            interface BreachedOptions extends Intel.Options {
            }
            interface BreachedRequest extends BreachedOptions {
                hash_type: string;
                hash_prefix: string;
            }
            enum PasswordStatus {
                BREACHED = 0,
                UNBREACHED = 1,
                INCONCLUSIVE = 2
            }
        }
    }
}
/**
 * Vault services interface definitions
 */
export declare namespace Vault {
    enum KeyPurpose {
        SIGNING = "signing",
        ENCRYPTION = "encryption",
        JWT = "jwt"
    }
    enum AsymmetricAlgorithm {
        Ed25519 = "ED25519",
        RSA2048_PKCS1V15_SHA256 = "RSA-PKCS1V15-2048-SHA256",
        RSA2048_OAEP_SHA256 = "RSA-OAEP-2048-SHA256",
        ES256 = "ES256",
        ES384 = "ES384",
        ES512 = "ES512",
        ES256K = "ES256K",
        RSA2048_OAEP_SHA1 = "RSA-OAEP-2048-SHA1",
        RSA2048_OAEP_SHA512 = "RSA-OAEP-2048-SHA512",
        RSA3072_OAEP_SHA1 = "RSA-OAEP-3072-SHA1",
        RSA3072_OAEP_SHA256 = "RSA-OAEP-3072-SHA256",
        RSA3072_OAEP_SHA512 = "RSA-OAEP-3072-SHA512",
        RSA4096_OAEP_SHA1 = "RSA-OAEP-4096-SHA1",
        RSA4096_OAEP_SHA256 = "RSA-OAEP-4096-SHA256",
        RSA4096_OAEP_SHA512 = "RSA-OAEP-4096-SHA512",
        RSA2048_PSS_SHA256 = "RSA-PSS-2048-SHA256",
        RSA3072_PSS_SHA256 = "RSA-PSS-3072-SHA256",
        RSA4096_PSS_SHA256 = "RSA-PSS-4096-SHA256",
        RSA4096_PSS_SHA512 = "RSA-PSS-4096-SHA512",
        RSA = "RSA-PKCS1V15-2048-SHA256"
    }
    enum SymmetricAlgorithm {
        HS256 = "HS256",
        HS384 = "HS384",
        HS512 = "HS512",
        AES128_CFB = "AES-CFB-128",
        AES256_CFB = "AES-CFB-256",
        AES256_GCM = "AES-GCM-256",
        AES = "AES-CFB-128"
    }
    enum ItemType {
        ASYMMETRIC_KEY = "asymmetric_key",
        SYMMETRIC_KEY = "symmetric_key",
        SECRET = "secret",
        PANGEA_TOKEN = "pangea_token"
    }
    enum ItemState {
        ENABLED = "ENABLED",
        DISABLED = "disabled"
    }
    enum ItemVersionState {
        ACTIVE = "active",
        DEACTIVATED = "deactivated",
        SUSPENDED = "suspended",
        COMPROMISED = "compromised",
        DESTROYED = "destroyed"
    }
    enum ItemOrder {
        ASC = "asc",
        DESC = "desc"
    }
    enum ItemOrderBy {
        TYPE = "type",
        CREATED_AT = "created_at",
        DESTROYED_AT = "destroyed_at",
        PURPOSE = "purpose",
        EXPIRATION = "expiration",
        LAST_ROTATED = "last_rotated",
        NEXT_ROTATION = "next_rotation",
        NAME = "name",
        FOLDER = "folder",
        VERSION = "version"
    }
    type Metadata = Object;
    type Tags = string[];
    type EncodedPublicKey = string;
    type EncodedPrivateKey = string;
    type EncodedSymmetricKey = string;
    interface StateChangeOptions {
        version?: number;
        destroy_period?: string;
    }
    interface StateChangeRequest extends StateChangeOptions {
        id: string;
        state: Vault.ItemVersionState;
    }
    interface StateChangeResult {
        id: string;
        version: number;
        state: string;
        destroy_at?: string;
    }
    interface DeleteRequest {
        id: string;
    }
    interface DeleteResult {
        id: string;
    }
    interface ItemData {
        type: string;
        id: string;
        item_state?: string;
        current_version?: ItemVersionData;
        name?: string;
        folder?: string;
        metadata?: Metadata;
        tags?: Tags;
        rotation_frequency?: string;
        rotation_state?: string;
        last_rotated?: string;
        next_rotation?: string;
        expiration?: string;
        created_at: string;
        algorithm: string;
        purpose: string;
    }
    interface ListItemData extends ItemData {
        compromised_versions: ItemVersionData[];
    }
    interface ListResult {
        items: ListItemData[];
        count: number;
        last?: string;
    }
    interface ListOptions {
        filter?: Object;
        last?: string;
        size?: number;
        order?: Vault.ItemOrder;
        order_by?: Vault.ItemOrderBy;
    }
    interface UpdateOptions {
        name?: string;
        folder?: string;
        metadata?: Metadata;
        tags?: Tags;
        rotation_frequency?: string;
        rotation_state?: ItemVersionState;
        rotation_grace_period?: string;
        expiration?: string;
        item_state?: string;
    }
    interface UpdateRequest extends UpdateOptions {
        id: string;
    }
    interface UpdateResult {
        id: string;
    }
    interface GetOptions {
        version?: number | string;
        verbose?: boolean;
        version_state?: ItemVersionState;
    }
    interface GetRequest extends GetOptions {
        id: string;
    }
    interface ItemVersionData {
        version: number;
        state: string;
        created_at: string;
        destroy_at?: string;
        public_key?: EncodedPublicKey;
        secret?: string;
    }
    interface GetResult extends ItemData {
        rotation_grace_period?: string;
        versions: ItemVersionData[];
    }
    namespace JWT {
        interface SignRequest {
            id: string;
            payload: string;
        }
        interface SignResult {
            jws: string;
        }
        interface VerifyRequest {
            jws: string;
        }
        interface VerifyResult {
            valid_signature: boolean;
        }
    }
    namespace JWK {
        interface Header {
            alg: string;
            kid?: string;
            kty: string;
            use?: string;
        }
        interface JWKrsa extends Header {
            n: string;
            e: string;
            d?: string;
        }
        interface JWKec extends Header {
            crv: string;
            d?: string;
            x: string;
            y: string;
        }
        interface JWK extends Header {
        }
        interface GetResult {
            keys: [JWKrsa | JWKec][];
        }
        interface GetOptions {
            version?: string;
        }
        interface GetRequest extends GetOptions {
            id: string;
        }
    }
    namespace Common {
        interface StoreOptions {
            folder?: string;
            metadata?: Metadata;
            tags?: Tags;
            rotation_frequency?: string;
            rotation_state?: ItemVersionState;
            expiration?: string;
        }
        interface StoreRequest {
            type: Vault.ItemType;
            name: string;
        }
        interface StoreResult {
            id: string;
            type: string;
            version: number;
        }
        interface GenerateRequest {
            type: Vault.ItemType;
            name: string;
        }
        interface GenerateOptions {
            folder?: string;
            metadata?: Metadata;
            tags?: Tags;
            rotation_frequency?: string;
            rotation_state?: ItemVersionState;
            expiration?: string;
        }
        interface GenerateResult {
            id: string;
            type: string;
            version: number;
        }
        interface RotateRequest {
            id: string;
        }
        interface RotateOptions {
            rotation_state?: ItemVersionState;
        }
        interface RotateResult {
            id: string;
            version: number;
            type: string;
        }
    }
    namespace Secret {
        const Algorithm: {
            BASE32: string;
        };
        interface StoreOptions extends Common.StoreOptions {
        }
        interface StoreRequest extends Common.StoreRequest, StoreOptions {
            secret: string;
        }
        interface StoreResult extends Common.StoreResult {
            secret: string;
        }
        interface GenerateRequest extends Common.GenerateRequest, Common.GenerateOptions {
        }
        interface GenerateResult extends Common.GenerateRequest {
            secret: string;
        }
        namespace Secret {
            interface RotateOptions extends Common.RotateOptions {
            }
            interface RotateRequest extends Common.RotateRequest, RotateOptions {
                secret?: string;
            }
        }
        namespace Token {
            interface RotateRequest extends Common.RotateRequest {
                rotation_grace_period: string;
            }
        }
        interface RotateResult extends Common.RotateResult {
            secret: string;
        }
    }
    namespace Key {
        interface RotateOptions {
            key?: EncodedSymmetricKey;
            public_key?: EncodedPublicKey;
            private_key?: EncodedPrivateKey;
        }
        interface RotateRequest extends Common.RotateRequest, RotateOptions {
        }
        interface RotateResult extends Common.RotateResult {
            algorithm: string;
            purpose: string;
            public_key?: EncodedPublicKey;
        }
    }
    namespace Asymmetric {
        interface GenerateOptions extends Common.GenerateOptions {
        }
        interface GenerateRequest extends Common.GenerateRequest, GenerateOptions {
            algorithm: Vault.AsymmetricAlgorithm;
            purpose: Vault.KeyPurpose;
        }
        interface GenerateResult extends Common.GenerateResult {
            algorithm: string;
            purpose: string;
            public_key: EncodedPublicKey;
        }
        interface StoreOptions extends Common.StoreOptions {
        }
        interface StoreRequest extends Common.StoreRequest, StoreOptions {
            private_key: EncodedPrivateKey;
            public_key: EncodedPublicKey;
            algorithm: Vault.AsymmetricAlgorithm;
            purpose: Vault.KeyPurpose;
        }
        interface StoreResult extends Common.StoreResult {
            public_key: EncodedPublicKey;
            algorithm: string;
            purpose: string;
        }
        interface SignOptions {
            version?: number;
        }
        interface SignRequest extends SignOptions {
            id: string;
            message: string;
        }
        interface SignResult {
            id: string;
            version: number;
            signature: string;
            algorithm: string;
            public_key?: EncodedPublicKey;
        }
        interface VerifyOptions {
            version?: number;
        }
        interface VerifyRequest extends VerifyOptions {
            id: string;
            message: string;
            signature: string;
        }
        interface VerifyResult {
            id: string;
            version: number;
            algorithm: string;
            valid_signature: boolean;
        }
    }
    namespace Symmetric {
        interface StoreOptions extends Common.StoreOptions {
        }
        interface StoreRequest extends Common.StoreRequest, StoreOptions {
            key: EncodedSymmetricKey;
            algorithm: Vault.SymmetricAlgorithm;
            purpose: Vault.KeyPurpose;
        }
        interface StoreResult extends Common.StoreResult {
            algorithm?: string;
            purpose?: string;
        }
        interface GenerateOptions extends Common.GenerateOptions {
        }
        interface GenerateRequest extends Common.GenerateRequest, GenerateOptions {
            algorithm: Vault.SymmetricAlgorithm;
            purpose: Vault.KeyPurpose;
        }
        interface GenerateResult extends Common.GenerateResult {
            algorithm: string;
            purpose: string;
        }
        interface EncryptOptions {
            version?: number;
            additional_data?: string;
        }
        interface EncryptRequest extends EncryptOptions {
            id: string;
            plain_text: string;
        }
        interface EncryptResult {
            id: string;
            version: number;
            algorithm: string;
            cipher_text: string;
        }
        interface DecryptOptions {
            version?: number;
            additional_data?: string;
        }
        interface DecryptRequest extends DecryptOptions {
            id: string;
            cipher_text: string;
        }
        interface DecryptResult {
            id: string;
            version?: number;
            algorithm: string;
            plain_text: string;
        }
    }
    namespace Folder {
        interface CreateRequest {
            name: string;
            folder: string;
            metadata?: Metadata;
            tags?: Tags;
        }
        interface CreateResult {
            id: string;
        }
    }
}
export declare namespace AuthN {
    enum IDProvider {
        FACEBOOK = "facebook",
        GITHUB = "github",
        GOOGLE = "google",
        MICROSOFT_ONLINE = "microsoftonline",
        PASSWORD = "password"
    }
    enum ItemOrder {
        ASC = "asc",
        DESC = "desc"
    }
    type Scopes = string[];
    interface Profile {
        [key: string]: string;
    }
    enum MFAProvider {
        TOTP = "totp",
        EMAIL_OTP = "email_otp",
        SMS_OTP = "sms_otp"
    }
    enum FlowType {
        SIGNIN = "signin",
        SIGNUP = "signup"
    }
    interface UserItem {
        profile: Profile;
        id: string;
        email: string;
        scopes: Scopes;
        id_providers: string[];
        mfa_providers: string[];
        require_mfa: boolean;
        verified: boolean;
        disabled: boolean;
        last_login_at: string;
        created_at: string;
    }
    interface PasswordRequirements {
        password_chars_min: number;
        password_chars_max: number;
        password_lower_min: number;
        password_upper_min: number;
        password_punct_min: number;
    }
    enum TokenType {
        USER = "user",
        SERVICE = "service",
        CLIENT = "client",
        SESSION = "session"
    }
    interface LoginToken {
        token: string;
        id: string;
        identity: string;
        type: TokenType;
        life: number;
        expire: string;
        email: string;
        scopes: Scopes;
        profile: Profile;
        created_at: string;
    }
    interface SessionToken {
        id: string;
        identity: string;
        type: TokenType;
        life: number;
        expire: string;
        email: string;
        scopes: Scopes;
        profile: Profile;
        created_at: string;
    }
    namespace Flow {
        enum Step {
            START = "start",
            VERIFY_CAPTCHA = "verify/captcha",
            SIGNUP = "signup",
            VERIFY_EMAIL = "verify/email",
            VERIFY_PASSWORD = "verify/password",
            VERIFY_SOCIAL = "verify/social",
            ENROLL_MFA_START = "enroll/mfa/start",
            ENROLL_MFA_COMPLETE = "enroll/mfa/complete",
            VERIFY_MFA_START = "verify/mfa/start",
            VERIFY_MFA_COMPLETE = "verify/mfa/complete",
            COMPLETE = "complete"
        }
        interface Result {
            flow_id: string;
            next_step: Step;
            error?: string;
            complete?: object;
            enroll_mfa_start?: {
                mfa_providers: MFAProvider[];
            };
            enroll_mfa_complete?: {
                totp_secret?: {
                    qr_image: string;
                    secret: string;
                };
            };
            signup?: {
                social_signup?: {
                    redirect_uri: object;
                };
                password_signup?: PasswordRequirements;
            };
            verify_captcha?: {
                site_key: string;
            };
            verify_email?: object;
            verify_mfa_start?: {
                mfa_providers: MFAProvider[];
            };
            verify_mfa_complete?: object;
            verify_password?: PasswordRequirements;
            verify_social?: {
                redirect_uri: object;
            };
        }
        namespace Reset {
            interface PasswordOptions {
                cb_state?: string;
                cb_code?: string;
                cancel?: boolean;
            }
            interface PasswordRequest extends PasswordOptions {
                flow_id: string;
                password: string;
            }
            interface PasswordResult extends Flow.Result {
            }
        }
        namespace Enroll {
            namespace MFA {
                interface StartRequest extends StartOptions {
                    flow_id: string;
                    mfa_provider: MFAProvider;
                }
                interface StartOptions {
                    phone?: string;
                }
                interface CompleteRequest extends CompleteOptions {
                    flow_id: string;
                }
                interface CompleteOptions {
                    cancel?: boolean;
                    code?: string;
                }
            }
        }
        namespace Verify {
            interface CaptchaRequest {
                flow_id: string;
                code: string;
            }
            interface EmailOptions {
                cb_state?: string;
                cb_code?: string;
            }
            interface EmailRequest extends EmailOptions {
                flow_id: string;
            }
            interface PasswordOptions {
                password?: string;
                cancel?: boolean;
            }
            interface PasswordRequest {
                flow_id: string;
            }
            interface SocialRequest {
                flow_id: string;
                cb_state: string;
                cb_code: string;
            }
            namespace MFA {
                interface StartRequest {
                    flow_id: string;
                    mfa_provider: MFAProvider;
                }
                interface CompleteOptions {
                    cancel?: boolean;
                    code?: string;
                }
                interface CompleteRequest extends CompleteOptions {
                    flow_id: string;
                }
            }
        }
        interface CompleteRequest {
            flow_id: string;
        }
        interface CompleteResult {
            refresh_token: LoginToken;
            active_token?: LoginToken;
        }
        interface StartRequest extends StartOptions {
        }
        interface StartOptions {
            email?: string;
            flow_types?: FlowType[];
            provider?: AuthN.IDProvider;
            cb_uri?: string;
        }
        namespace Signup {
            interface PasswordRequest {
                flow_id: string;
                password: string;
                first_name: string;
                last_name: string;
            }
            interface SocialRequest {
                flow_id: string;
                cb_state: string;
                cb_code: string;
            }
        }
    }
    namespace Client {
        interface UserinfoRequest {
            code: string;
        }
        interface UserinfoResult {
            refresh_token: LoginToken;
            active_token: LoginToken;
        }
        interface JWKSResult {
            keys: [Vault.JWK.JWKrsa | Vault.JWK.JWKec][];
        }
        namespace Token {
            interface CheckRequest {
                token: string;
            }
            interface CheckResult extends SessionToken {
            }
        }
        namespace Password {
            interface UpdateRequest {
                token: string;
                old_password: string;
                new_password: string;
            }
        }
        namespace Session {
            interface InvalidateRequest {
                token: string;
                session_id: string;
            }
            interface ListOptions {
                filter?: Object;
                last?: string;
                order?: string;
                order_by?: string;
                size?: number;
            }
            interface ListRequest extends ListOptions {
                token: string;
            }
            interface RefreshOptions {
                user_token?: string;
            }
            interface RefreshRequest extends RefreshOptions {
                refresh_token: string;
            }
            interface RefreshResult {
                refresh_token: LoginToken;
                active_token?: LoginToken;
            }
        }
    }
    namespace Session {
        interface Item {
            id: string;
            type: TokenType;
            life: number;
            expire: string;
            profile: Profile;
            created_at: string;
            scopes?: Scopes;
            active_token?: SessionToken;
        }
        interface ListRequest {
            filter?: Object;
            last?: string;
            order?: string;
            order_by?: string;
            size?: number;
        }
        interface ListResult {
            sessions: Item[];
            last?: string;
        }
    }
    namespace User {
        interface CreateOptions {
            verified?: boolean;
            require_mfa?: boolean;
            profile?: Profile;
            scopes?: Scopes;
        }
        interface CreateRequest extends CreateOptions {
            email: string;
            authenticator: string;
            id_provider: IDProvider;
        }
        interface CreateResult {
            id: string;
            email: string;
            profile: Profile;
            id_providers: string[];
            require_mfa: boolean;
            verified: boolean;
            last_login_at: string;
            disable?: boolean;
            mfa_provider?: MFAProvider[];
        }
        namespace Delete {
            interface EmailRequest {
                email: string;
            }
            interface IDRequest {
                id: string;
            }
        }
        interface InviteItem {
            id: string;
            inviter: string;
            invite_org: string;
            email: string;
            callback: string;
            state: string;
            require_mfa: boolean;
            created_at: string;
            expire: string;
        }
        interface InviteRequest extends InviteOptions {
            inviter: string;
            email: string;
            callback: string;
            state: string;
        }
        interface InviteResult extends InviteItem {
        }
        interface InviteOptions {
            require_mfa?: boolean;
        }
        enum ListOrderBy {
            ID = "id",
            CREATED_AT = "created_at",
            LAST_LOGIN_AT = "last_login_at",
            EMAIL = "email"
        }
        interface ListRequest {
            filter?: Object;
            last?: string;
            order?: AuthN.ItemOrder;
            order_by?: AuthN.User.ListOrderBy;
            size?: number;
            use_new?: boolean;
        }
        interface ListResult {
            users: UserItem[];
            last?: string;
            count: number;
        }
        namespace Password {
            interface ResetRequest {
                user_id: string;
                new_password: string;
            }
        }
        namespace Invite {
            enum OrderBy {
                ID = "id",
                CREATED_AT = "created_at",
                TYPE = "type",
                EXPIRE = "expire",
                CALLBACK = "callback",
                STATE = "state",
                EMAIL = "email",
                INVITER = "inviter",
                INVITE_ORG = "invite_org"
            }
            interface DeleteRequest {
                id: string;
            }
            interface ListRequest {
                filter?: Object;
                last?: string;
                order?: ItemOrder;
                order_by?: OrderBy;
                size?: number;
            }
            interface ListResult {
                invites: InviteItem[];
            }
        }
        namespace Login {
            interface PasswordOptions {
                extra_profile?: Profile;
            }
            interface PasswordRequest extends PasswordOptions {
                email: string;
                password: string;
            }
            interface SocialOptions {
                extra_profile?: Profile;
            }
            interface SocialRequest extends SocialOptions {
                provider: IDProvider;
                email: string;
                social_id: string;
            }
            interface LoginResult {
                refresh_token: LoginToken;
                active_token?: LoginToken;
            }
        }
        namespace MFA {
            interface DeleteRequest {
                user_id: string;
                mfa_provider: MFAProvider;
            }
            interface EnrollRequest {
                user_id: string;
                mfa_provider: MFAProvider;
                code: string;
            }
            interface StartRequest extends StartOptions {
                user_id: string;
                mfa_provider: MFAProvider;
            }
            interface StartOptions {
                enroll?: boolean;
                phone?: string;
            }
            interface StartResult {
                totp_secret?: {
                    qr_image: string;
                    secret: string;
                };
            }
            interface VerifyRequest {
                user_id: string;
                mfa_provider: string;
                code: string;
            }
        }
        namespace Profile {
            interface GetResult extends UserItem {
            }
            namespace Get {
                interface EmailRequest {
                    email: string;
                }
                interface IDRequest {
                    id: string;
                }
            }
            namespace Update {
                interface EmailRequest {
                    email: string;
                    profile: Profile;
                }
                interface IDRequest {
                    id: string;
                    profile: Profile;
                }
            }
            interface UpdateResult extends UserItem {
            }
        }
        namespace Update {
            interface EmailRequest extends Options {
                email: string;
            }
            interface IDRequest extends Options {
                id: string;
            }
            interface Options {
                authenticator?: string;
                disabled?: boolean;
                require_mfa?: boolean;
                verified?: boolean;
            }
        }
        interface UpdateResult extends UserItem {
        }
        interface VerifyRequest {
            id_provider: IDProvider;
            email: string;
            authenticator: string;
        }
        interface VerifyResult {
            id: string;
            email: string;
            profile: Profile;
            scopes: Scopes;
            id_providers: string[];
            require_mfa: boolean;
            mfa_providers: string[];
            verified: boolean;
            disabled: boolean;
            last_login_at?: string;
        }
    }
}
