import { Signer } from "./utils/signer.js";
/**
 * PangeaConfig options
 */
export interface ConfigOptions {
    domain?: string;
    environment?: ConfigEnv;
    configID?: string;
    insecure?: boolean;
    requestRetries?: number;
    requestTimeout?: number;
    queuedRetryEnabled?: boolean;
    pollResultTimeoutMs?: number;
    queuedRetries?: number;
    customUserAgent?: string;
}
export interface PostOptions {
    pollResultSync?: boolean;
}
export declare enum ConfigEnv {
    LOCAL = "local",
    PRODUCTION = "production"
}
export interface Dictionary {
    [key: string]: string | boolean | number | Dictionary;
}
/**
 * Secure Audit interface definitions
 */
export declare namespace Audit {
    interface LogOptions {
        verbose?: boolean;
        signer?: Signer;
        skipEventVerification?: boolean;
        verify?: boolean;
        publicKeyInfo?: Object;
    }
    interface LogData {
        event: Audit.Event;
        verbose?: boolean;
        signature?: string;
        public_key?: string;
        prev_root?: string;
    }
    interface Event {
        [key: string]: Object | string | boolean | number | Date;
    }
    interface EventEnvelope {
        event: Event;
        signature?: string;
        public_key?: string;
        received_at: string;
    }
    interface AuditRecord {
        envelope: Audit.EventEnvelope;
        hash: string;
        membership_proof?: string;
        published?: boolean;
        leaf_index?: string;
        consistency_verification?: string;
        membership_verification?: string;
        signature_verification?: string;
    }
    interface Root {
        url?: string;
        published_at?: string;
        size: number;
        root_hash: string;
        consistency_proof: string[];
        tree_name: string;
    }
    interface LogResponse {
        hash: string;
        envelope: Audit.EventEnvelope;
        unpublished_root?: string;
        membership_proof?: string;
        consistency_proof?: string[];
        consistency_verification?: string;
        membership_verification?: string;
        signature_verification?: string;
    }
    interface SearchOptions {
        verifyConsistency?: boolean;
        skipEventVerification?: boolean;
    }
    interface SearchResponse {
        id: string;
        expires_at: string;
        count: number;
        events: Audit.AuditRecord[];
        root?: Root;
        unpublished_root?: Root;
    }
    interface SearchRestriction {
        actor?: Array<string>;
        action?: Array<string>;
        source?: Array<string>;
        status?: Array<string>;
        target?: Array<string>;
    }
    interface SearchParamsOptions {
        limit?: number;
        max_results?: number;
        start?: string;
        end?: string;
        order?: string;
        order_by?: string;
        search_restriction?: Audit.SearchRestriction;
        verbose?: boolean;
    }
    interface SearchParams extends SearchParamsOptions {
        query: string;
    }
    interface RootParams {
        tree_size?: number;
    }
    interface ResultResponse {
        events: AuditRecord[];
        count: number;
        root?: Root;
    }
    interface RootRequest {
        tree_size?: number;
    }
    interface RootResult extends Root {
        data: Root;
    }
}
export declare namespace Redact {
    interface TextResult {
        redacted_text?: string;
        count: number;
    }
    interface StructuredResult {
        redacted_data?: object;
        count: number;
    }
    interface Options {
        debug?: boolean;
        rules?: string[];
        rulesets?: string[];
        return_result?: boolean;
    }
    interface TextOptions extends Options {
    }
    interface StructuredOptions extends Options {
        jsonp?: string[];
        format?: string;
    }
    interface TextParams extends TextOptions {
        text: string;
    }
    interface StructuredParams extends StructuredOptions {
        data: Object;
    }
}
export declare namespace Embargo {
    interface Sanction {
        list_name: string;
        embargoed_country_name: string;
        embargoed_country_iso_code: string;
        issuing_country: string;
        annotations: object;
    }
    interface CheckResult {
        sanctions: Sanction[];
    }
}
export declare namespace FileScan {
    interface ScanRequest {
        verbose?: boolean;
        raw?: boolean;
        provider?: string;
        filepath?: string;
        file?: string;
    }
    interface Options extends PostOptions {
    }
    interface ScanResult {
        parameter?: Dictionary;
        raw_data?: Dictionary;
        data: {
            category: string[];
            score: number;
            verdict: string;
        };
    }
}
/**
 * Intel services interface definitions
 */
export declare namespace Intel {
    enum HashType {
        SHA256 = "sha256",
        SHA1 = "sha1",
        SHA512 = "sha512",
        NTLM = "ntlm"
    }
    interface Options {
        verbose?: boolean;
        raw?: boolean;
        provider?: string;
    }
    interface ReputationData {
        category: string[];
        score: number;
        verdict: string;
    }
    interface ReputationResult extends CommonResult {
        data: ReputationData;
    }
    namespace File {
        interface Options extends Intel.Options {
        }
        interface Params {
            hash: string;
            hash_type: string;
        }
        export interface ReputationOptions extends Options {
        }
        export interface ReputationResult extends Intel.ReputationResult {
        }
        export interface ReputationRequest extends Params, ReputationOptions {
        }
        export {};
    }
    namespace Domain {
        interface Options extends Intel.Options {
        }
        interface Params {
            domain: string;
        }
        export interface ReputationOptions extends Options {
        }
        export interface ReputationResult extends Intel.ReputationResult {
        }
        export interface ReputationRequest extends Params, ReputationOptions {
        }
        export interface WhoIsOptions extends Options {
        }
        export interface WhoIsRequest extends Params, WhoIsOptions {
        }
        export interface WhoIsData {
            domain_name: string;
            domain_availability: string;
            created_date?: string;
            updated_date?: string;
            expires_date?: string;
            host_names?: string[];
            ips?: string[];
            registrar_name?: string;
            contact_email?: string;
            estimated_domain_age?: number;
            registrant_organization?: string;
            registrant_country?: string;
        }
        export interface WhoIsResult extends Intel.CommonResult {
            data: WhoIsData;
        }
        export {};
    }
    namespace URL {
        interface Options extends Intel.Options {
        }
        interface Params {
            url: string;
        }
        export interface ReputationOptions extends Options {
        }
        export interface ReputationResult extends Intel.ReputationResult {
        }
        export interface ReputationRequest extends Params, ReputationOptions {
        }
        export {};
    }
    namespace IP {
        interface Options extends Intel.Options {
        }
        interface Params {
            ip: string;
        }
        export interface GeolocateOptions extends Options {
        }
        export interface GeolocateRequest extends Params, GeolocateOptions {
        }
        export interface DomainOptions extends Options {
        }
        export interface DomainRequest extends Params, DomainOptions {
        }
        export interface VPNOptions extends Options {
        }
        export interface VPNRequest extends Params, VPNOptions {
        }
        export interface ProxyOptions extends Options {
        }
        export interface ProxyRequest extends Params, ProxyOptions {
        }
        export interface ReputationOptions extends Options {
        }
        export interface ReputationResult extends Intel.ReputationResult {
        }
        export interface ReputationParams extends Params, ReputationOptions {
        }
        export interface GeolocateData {
            country: string;
            city: string;
            latitude: number;
            longitude: number;
            postal_code: string;
            country_code: string;
        }
        export interface GeolocateResult extends CommonResult {
            data: GeolocateData;
        }
        export interface DomainResult extends CommonResult {
            data: {
                domain_found: boolean;
                domain?: string;
            };
        }
        export interface VPNResult extends CommonResult {
            data: {
                is_vpn: boolean;
            };
        }
        export interface ProxyResult extends CommonResult {
            data: {
                is_proxy: boolean;
            };
        }
        export {};
    }
    interface CommonResult {
        parameter?: Dictionary;
        raw_data?: Dictionary;
    }
    namespace User {
        interface BreachedData {
            found_in_breach: boolean;
            breach_count: number;
        }
        interface BreachedResult extends Intel.CommonResult {
            data: BreachedData;
        }
        namespace User {
            interface BreachedOptions extends Intel.Options {
                start?: string;
                end?: string;
            }
            interface BreachedEmailRequest extends BreachedOptions {
                email: string;
            }
            interface BreachedUsernameRequest extends BreachedOptions {
                username: string;
            }
            interface BreachedIPRequest extends BreachedOptions {
                ip: string;
            }
            interface BreachedPhoneRequest extends BreachedOptions {
                phone_number: string;
            }
            interface BreachedResult extends Intel.User.BreachedResult {
            }
            type BreachedRequest = BreachedEmailRequest | BreachedIPRequest | BreachedPhoneRequest | BreachedUsernameRequest;
        }
        namespace Password {
            interface BreachedOptions extends Intel.Options {
            }
            interface BreachedRequest extends BreachedOptions {
                hash_type: string;
                hash_prefix: string;
            }
            enum PasswordStatus {
                BREACHED = 0,
                UNBREACHED = 1,
                INCONCLUSIVE = 2
            }
        }
    }
}
/**
 * Vault services interface definitions
 */
export declare namespace Vault {
    enum KeyPurpose {
        SIGNING = "signing",
        ENCRYPTION = "encryption",
        JWT = "jwt"
    }
    enum AsymmetricAlgorithm {
        Ed25519 = "ED25519",
        RSA2048_PKCS1V15_SHA256 = "RSA-PKCS1V15-2048-SHA256",
        RSA2048_OAEP_SHA256 = "RSA-OAEP-2048-SHA256",
        ES256 = "ES256",
        ES384 = "ES384",
        ES512 = "ES512",
        ES256K = "ES256K",
        RSA2048_OAEP_SHA1 = "RSA-OAEP-2048-SHA1",
        RSA2048_OAEP_SHA512 = "RSA-OAEP-2048-SHA512",
        RSA3072_OAEP_SHA1 = "RSA-OAEP-3072-SHA1",
        RSA3072_OAEP_SHA256 = "RSA-OAEP-3072-SHA256",
        RSA3072_OAEP_SHA512 = "RSA-OAEP-3072-SHA512",
        RSA4096_OAEP_SHA1 = "RSA-OAEP-4096-SHA1",
        RSA4096_OAEP_SHA256 = "RSA-OAEP-4096-SHA256",
        RSA4096_OAEP_SHA512 = "RSA-OAEP-4096-SHA512",
        RSA2048_PSS_SHA256 = "RSA-PSS-2048-SHA256",
        RSA3072_PSS_SHA256 = "RSA-PSS-3072-SHA256",
        RSA4096_PSS_SHA256 = "RSA-PSS-4096-SHA256",
        RSA4096_PSS_SHA512 = "RSA-PSS-4096-SHA512",
        RSA = "RSA-PKCS1V15-2048-SHA256"
    }
    enum SymmetricAlgorithm {
        HS256 = "HS256",
        HS384 = "HS384",
        HS512 = "HS512",
        AES128_CFB = "AES-CFB-128",
        AES256_CFB = "AES-CFB-256",
        AES256_GCM = "AES-GCM-256",
        AES = "AES-CFB-128"
    }
    enum ItemType {
        ASYMMETRIC_KEY = "asymmetric_key",
        SYMMETRIC_KEY = "symmetric_key",
        SECRET = "secret",
        PANGEA_TOKEN = "pangea_token"
    }
    enum ItemState {
        ENABLED = "ENABLED",
        DISABLED = "disabled"
    }
    enum ItemVersionState {
        ACTIVE = "active",
        DEACTIVATED = "deactivated",
        SUSPENDED = "suspended",
        COMPROMISED = "compromised",
        DESTROYED = "destroyed"
    }
    enum ItemOrder {
        ASC = "asc",
        DESC = "desc"
    }
    enum ItemOrderBy {
        TYPE = "type",
        CREATED_AT = "created_at",
        DESTROYED_AT = "destroyed_at",
        PURPOSE = "purpose",
        EXPIRATION = "expiration",
        LAST_ROTATED = "last_rotated",
        NEXT_ROTATION = "next_rotation",
        NAME = "name",
        FOLDER = "folder",
        VERSION = "version"
    }
    type Metadata = Object;
    type Tags = string[];
    type EncodedPublicKey = string;
    type EncodedPrivateKey = string;
    type EncodedSymmetricKey = string;
    interface StateChangeOptions {
        version?: number;
        destroy_period?: string;
    }
    interface StateChangeRequest extends StateChangeOptions {
        id: string;
        state: Vault.ItemVersionState;
    }
    interface StateChangeResult {
        id: string;
        version: number;
        state: string;
        destroy_at?: string;
    }
    interface DeleteRequest {
        id: string;
    }
    interface DeleteResult {
        id: string;
    }
    interface ItemData {
        type: string;
        id: string;
        item_state?: string;
        current_version?: ItemVersionData;
        name?: string;
        folder?: string;
        metadata?: Metadata;
        tags?: Tags;
        rotation_frequency?: string;
        rotation_state?: string;
        last_rotated?: string;
        next_rotation?: string;
        expiration?: string;
        created_at: string;
        algorithm: string;
        purpose: string;
    }
    interface ListItemData extends ItemData {
        compromised_versions: ItemVersionData[];
    }
    interface ListResult {
        items: ListItemData[];
        count: number;
        last?: string;
    }
    interface ListOptions {
        filter?: Object;
        last?: string;
        size?: number;
        order?: Vault.ItemOrder;
        order_by?: Vault.ItemOrderBy;
    }
    interface UpdateOptions {
        name?: string;
        folder?: string;
        metadata?: Metadata;
        tags?: Tags;
        rotation_frequency?: string;
        rotation_state?: ItemVersionState;
        rotation_grace_period?: string;
        expiration?: string;
        item_state?: string;
    }
    interface UpdateRequest extends UpdateOptions {
        id: string;
    }
    interface UpdateResult {
        id: string;
    }
    interface GetOptions {
        version?: number | string;
        verbose?: boolean;
        version_state?: ItemVersionState;
    }
    interface GetRequest extends GetOptions {
        id: string;
    }
    interface ItemVersionData {
        version: number;
        state: string;
        created_at: string;
        destroy_at?: string;
        public_key?: EncodedPublicKey;
        secret?: string;
    }
    interface GetResult extends ItemData {
        rotation_grace_period?: string;
        versions: ItemVersionData[];
    }
    namespace JWT {
        interface SignRequest {
            id: string;
            payload: string;
        }
        interface SignResult {
            jws: string;
        }
        interface VerifyRequest {
            jws: string;
        }
        interface VerifyResult {
            valid_signature: boolean;
        }
    }
    namespace JWK {
        interface Header {
            alg: string;
            kid?: string;
            kty: string;
            use?: string;
        }
        interface JWKrsa extends Header {
            n: string;
            e: string;
            d?: string;
        }
        interface JWKec extends Header {
            crv: string;
            d?: string;
            x: string;
            y: string;
        }
        interface JWK extends Header {
        }
        interface GetResult {
            keys: [JWKrsa | JWKec][];
        }
        interface GetOptions {
            version?: string;
        }
        interface GetRequest extends GetOptions {
            id: string;
        }
    }
    namespace Common {
        interface StoreOptions {
            folder?: string;
            metadata?: Metadata;
            tags?: Tags;
            rotation_frequency?: string;
            rotation_state?: ItemVersionState;
            expiration?: string;
        }
        interface StoreRequest {
            type: Vault.ItemType;
            name: string;
        }
        interface StoreResult {
            id: string;
            type: string;
            version: number;
        }
        interface GenerateRequest {
            type: Vault.ItemType;
            name: string;
        }
        interface GenerateOptions {
            folder?: string;
            metadata?: Metadata;
            tags?: Tags;
            rotation_frequency?: string;
            rotation_state?: ItemVersionState;
            expiration?: string;
        }
        interface GenerateResult {
            id: string;
            type: string;
            version: number;
        }
        interface RotateRequest {
            id: string;
        }
        interface RotateOptions {
            rotation_state?: ItemVersionState;
        }
        interface RotateResult {
            id: string;
            version: number;
            type: string;
        }
    }
    namespace Secret {
        const Algorithm: {
            BASE32: string;
        };
        interface StoreOptions extends Common.StoreOptions {
        }
        interface StoreRequest extends Common.StoreRequest, StoreOptions {
            secret: string;
        }
        interface StoreResult extends Common.StoreResult {
            secret: string;
        }
        interface GenerateRequest extends Common.GenerateRequest, Common.GenerateOptions {
        }
        interface GenerateResult extends Common.GenerateRequest {
            secret: string;
        }
        namespace Secret {
            interface RotateOptions extends Common.RotateOptions {
            }
            interface RotateRequest extends Common.RotateRequest, RotateOptions {
                secret?: string;
            }
        }
        namespace Token {
            interface RotateRequest extends Common.RotateRequest {
                rotation_grace_period: string;
            }
        }
        interface RotateResult extends Common.RotateResult {
            secret: string;
        }
    }
    namespace Key {
        interface RotateOptions {
            key?: EncodedSymmetricKey;
            public_key?: EncodedPublicKey;
            private_key?: EncodedPrivateKey;
        }
        interface RotateRequest extends Common.RotateRequest, RotateOptions {
        }
        interface RotateResult extends Common.RotateResult {
            algorithm: string;
            purpose: string;
            public_key?: EncodedPublicKey;
        }
    }
    namespace Asymmetric {
        interface GenerateOptions extends Common.GenerateOptions {
        }
        interface GenerateRequest extends Common.GenerateRequest, GenerateOptions {
            algorithm: Vault.AsymmetricAlgorithm;
            purpose: Vault.KeyPurpose;
        }
        interface GenerateResult extends Common.GenerateResult {
            algorithm: string;
            purpose: string;
            public_key: EncodedPublicKey;
        }
        interface StoreOptions extends Common.StoreOptions {
        }
        interface StoreRequest extends Common.StoreRequest, StoreOptions {
            private_key: EncodedPrivateKey;
            public_key: EncodedPublicKey;
            algorithm: Vault.AsymmetricAlgorithm;
            purpose: Vault.KeyPurpose;
        }
        interface StoreResult extends Common.StoreResult {
            public_key: EncodedPublicKey;
            algorithm: string;
            purpose: string;
        }
        interface SignOptions {
            version?: number;
        }
        interface SignRequest extends SignOptions {
            id: string;
            message: string;
        }
        interface SignResult {
            id: string;
            version: number;
            signature: string;
            algorithm: string;
            public_key?: EncodedPublicKey;
        }
        interface VerifyOptions {
            version?: number;
        }
        interface VerifyRequest extends VerifyOptions {
            id: string;
            message: string;
            signature: string;
        }
        interface VerifyResult {
            id: string;
            version: number;
            algorithm: string;
            valid_signature: boolean;
        }
    }
    namespace Symmetric {
        interface StoreOptions extends Common.StoreOptions {
        }
        interface StoreRequest extends Common.StoreRequest, StoreOptions {
            key: EncodedSymmetricKey;
            algorithm: Vault.SymmetricAlgorithm;
            purpose: Vault.KeyPurpose;
        }
        interface StoreResult extends Common.StoreResult {
            algorithm?: string;
            purpose?: string;
        }
        interface GenerateOptions extends Common.GenerateOptions {
        }
        interface GenerateRequest extends Common.GenerateRequest, GenerateOptions {
            algorithm: Vault.SymmetricAlgorithm;
            purpose: Vault.KeyPurpose;
        }
        interface GenerateResult extends Common.GenerateResult {
            algorithm: string;
            purpose: string;
        }
        interface EncryptOptions {
            version?: number;
            additional_data?: string;
        }
        interface EncryptRequest extends EncryptOptions {
            id: string;
            plain_text: string;
        }
        interface EncryptResult {
            id: string;
            version: number;
            algorithm: string;
            cipher_text: string;
        }
        interface DecryptOptions {
            version?: number;
            additional_data?: string;
        }
        interface DecryptRequest extends DecryptOptions {
            id: string;
            cipher_text: string;
        }
        interface DecryptResult {
            id: string;
            version?: number;
            algorithm: string;
            plain_text: string;
        }
    }
    namespace Folder {
        interface CreateRequest {
            name: string;
            folder: string;
            metadata?: Metadata;
            tags?: Tags;
        }
        interface CreateResult {
            id: string;
        }
    }
}
export declare namespace AuthN {
    enum IDProvider {
        FACEBOOK = "facebook",
        GITHUB = "github",
        GOOGLE = "google",
        MICROSOFT_ONLINE = "microsoftonline",
        PASSWORD = "password"
    }
    enum ItemOrder {
        ASC = "asc",
        DESC = "desc"
    }
    type Scopes = string[];
    interface Profile {
        [key: string]: string | undefined;
        first_name?: string;
        last_name?: string;
    }
    enum MFAProvider {
        TOTP = "totp",
        EMAIL_OTP = "email_otp",
        SMS_OTP = "sms_otp"
    }
    enum FlowType {
        SIGNIN = "signin",
        SIGNUP = "signup"
    }
    interface UserItem {
        id: string;
        email: string;
        profile: Profile;
        verified: boolean;
        disabled: boolean;
        accepted_eula_id?: string;
        accepted_privacy_policy_id?: string;
        last_login_at?: string;
        created_at: string;
        login_count: number;
        last_login_ip?: string;
        last_login_city?: string;
        last_login_country?: string;
        authenticators?: AuthN.User.Authenticators.Authenticator[];
    }
    interface PasswordRequirements {
        password_chars_min: number;
        password_chars_max: number;
        password_lower_min: number;
        password_upper_min: number;
        password_punct_min: number;
    }
    enum TokenType {
        USER = "user",
        SERVICE = "service",
        CLIENT = "client",
        SESSION = "session"
    }
    interface IPIntelligence {
        is_bad: boolean;
        is_vpn: boolean;
        is_proxy: boolean;
        reputation: Intel.ReputationData;
        geolocation: Intel.IP.GeolocateData;
    }
    interface DomainIntelligence {
        is_bad: boolean;
        reputation: Intel.ReputationData;
    }
    interface Intelligence {
        embargo: boolean;
        ip_intel: IPIntelligence;
        domain_intel: DomainIntelligence;
        user_intel: boolean;
    }
    interface SessionToken {
        id: string;
        type: TokenType;
        life: number;
        expire: string;
        identity: string;
        email: string;
        scopes: Scopes;
        profile: Profile;
        created_at: string;
        intelligence?: Intelligence;
    }
    interface LoginToken extends SessionToken {
        token: string;
    }
    namespace Agreements {
        enum AgreementType {
            EULA = "eula",
            PRIVACY_POLICY = "privacy_policy"
        }
        interface CreateRequest {
            type: AgreementType;
            name: string;
            text: string;
            active?: boolean;
        }
        interface AgreementInfo {
            type: string;
            id: string;
            created_at: string;
            updated_at: string;
            published_at: string;
            name: string;
            text: string;
            active: boolean;
        }
        interface CreateResult extends AgreementInfo {
        }
        interface DeleteRequest {
            type: AgreementType;
            id: string;
        }
        interface DeleteResult {
        }
        enum AgreementListOrderBy {
            ID = "id",
            CREATED_AT = "created_at",
            NAME = "name",
            TEXT = "text"
        }
        interface ListFilter {
            active?: boolean;
            created_at?: string;
            created_at__gt?: string;
            created_at__gte?: string;
            created_at__lt?: string;
            created_at__lte?: string;
            published_at?: string;
            published_at__gt?: string;
            published_at__gte?: string;
            published_at__lt?: string;
            published_at__lte?: string;
            type?: string;
            type__contains?: string[];
            type__in?: string[];
            id?: string;
            id__contains?: string[];
            id__in?: string[];
            name?: string;
            name__contains?: string[];
            name__in?: string[];
            text?: string;
            text__contains?: string[];
            text__in?: string[];
        }
        interface ListRequest {
            filter?: object | ListFilter;
            last?: string;
            order?: ItemOrder;
            order_by?: AgreementListOrderBy;
            size?: number;
        }
        interface ListResult {
            agreements: AgreementInfo[];
            count: number;
            last?: string;
        }
        interface UpdateRequest {
            type: AgreementType;
            id: string;
            name?: string;
            text?: string;
            active?: boolean;
        }
        interface UpdateResult extends AgreementInfo {
        }
    }
    namespace Flow {
        enum Choice {
            AGREEMENTS = "agreements",
            CAPTCHA = "captcha",
            EMAIL_OTP = "email_otp",
            MAGICLINK = "magiclink",
            PASSWORD = "password",
            PROFILE = "profile",
            PROVISIONAL_ENROLLMENT = "provisional_enrollment",
            RESET_PASSWORD = "reset_password",
            SET_EMAIL = "set_mail",
            SET_PASSWORD = "set_password",
            SMS_OTP = "sms_otp",
            SOCIAL = "social",
            TOTP = "totp",
            VERIFY_EMAIL = "verify_email"
        }
        interface ChoiceItem {
            choice: string;
            data: Dictionary;
        }
        interface Result {
            flow_id: string;
            flow_type: string[];
            email: string;
            disclaimer?: string;
            flow_phase: string;
            flow_choices: Flow.ChoiceItem[];
        }
        interface CompleteRequest {
            flow_id: string;
        }
        interface CompleteResult {
            refresh_token: LoginToken;
            active_token?: LoginToken;
        }
        interface StartRequest {
            cb_uri?: string;
            email?: string;
            flow_types?: FlowType[];
            invitation?: string;
        }
        interface StartResult extends Flow.Result {
        }
        namespace Restart {
            interface DataSMSOTP {
                phone: string;
            }
            type Data = Dictionary | DataSMSOTP;
        }
        interface RestartRequest {
            flow_id: string;
            choice: Choice;
            data: Restart.Data;
        }
        interface RestartResult extends Flow.Result {
        }
        namespace Update {
            interface DataAgreements {
                agreed: string[];
            }
            interface DataCaptcha {
                code: string;
            }
            interface DataEmailOTP {
                code: string;
            }
            interface DataMagiclink {
                state: string;
                code: string;
            }
            interface DataPassword {
                password: string;
            }
            interface DataProfile {
                profile: Profile;
            }
            interface DataProvisionalEnrollment {
                state: string;
                code: string;
            }
            interface DataResetPassword {
                state: string;
                code: string;
            }
            interface DataSetEmail {
                email: string;
            }
            interface DataSetPassword {
                password: string;
            }
            interface DataSMSOTP {
                code: string;
            }
            interface DataSocialProvider {
                social_provider: string;
                uri: string;
            }
            interface DataTOTP {
                code: string;
            }
            interface DataVerifyEmail {
                state: string;
                code: string;
            }
            type Data = Dictionary | DataAgreements | DataCaptcha | DataEmailOTP | DataMagiclink | DataPassword | DataProfile | DataProvisionalEnrollment | DataResetPassword | DataSetEmail | DataSetPassword | DataSMSOTP | DataSocialProvider | DataTOTP | DataVerifyEmail;
        }
        interface UpdateRequest {
            flow_id: string;
            choice: Flow.Choice;
            data: Flow.Update.Data;
        }
        interface UpdateResult extends Flow.Result {
        }
    }
    namespace Client {
        interface UserinfoRequest {
            code: string;
        }
        interface UserinfoResult {
            refresh_token: LoginToken;
            active_token: LoginToken;
        }
        interface JWKSResult {
            keys: [Vault.JWK.JWKrsa | Vault.JWK.JWKec][];
        }
        namespace Token {
            interface CheckRequest {
                token: string;
            }
            interface CheckResult extends LoginToken {
            }
        }
        namespace Password {
            interface UpdateRequest {
                token: string;
                old_password: string;
                new_password: string;
            }
        }
        namespace Session {
            interface InvalidateRequest {
                token: string;
                session_id: string;
            }
            interface ListOptions {
                filter?: Object | AuthN.Session.ListFilter;
                last?: string;
                order?: string;
                order_by?: string;
                size?: number;
            }
            interface ListRequest extends ListOptions {
                token: string;
            }
            interface RefreshOptions {
                user_token?: string;
            }
            interface RefreshRequest extends RefreshOptions {
                refresh_token: string;
            }
            interface RefreshResult {
                refresh_token: LoginToken;
                active_token?: LoginToken;
            }
        }
    }
    namespace Session {
        interface Item {
            id: string;
            type: TokenType;
            life: number;
            expire: string;
            profile: Profile;
            created_at: string;
            scopes?: Scopes;
            active_token?: SessionToken;
        }
        interface ListFilter {
            active_token_id?: string;
            active_token_id__contains?: string[];
            active_token_id__in?: string[];
            created_at?: string;
            created_at__gt?: string;
            created_at__gte?: string;
            created_at__lt?: string;
            created_at__lte?: string;
            email?: string;
            email__contains?: string[];
            email__in?: string[];
            expire?: string;
            expire__gt?: string;
            expire__gte?: string;
            expire__lt?: string;
            expire__lte?: string;
            id?: string;
            id__contains?: string[];
            id__in?: string[];
            identity?: string;
            identity__contains?: string[];
            identity__in?: string[];
            scopes?: string[];
            type?: string;
            type__contains?: string[];
            type__in?: string[];
        }
        interface ListRequest {
            filter?: Object | ListFilter;
            last?: string;
            order?: string;
            order_by?: string;
            size?: number;
        }
        interface ListResult {
            sessions: Item[];
            last?: string;
        }
    }
    namespace User {
        interface CreateOptions {
        }
        interface CreateRequest extends CreateOptions {
            email: string;
            profile: Profile;
        }
        interface CreateResult {
            id: string;
            email: string;
            profile: Profile;
            scopes?: Scopes;
            id_providers: string[];
            mfa_provider?: MFAProvider[];
            require_mfa: boolean;
            verified: boolean;
            disable: boolean;
            accepted_eula_id?: string;
            last_login_at?: string;
            created_at: string;
        }
        interface InviteItem {
            id: string;
            inviter: string;
            invite_org: string;
            email: string;
            callback: string;
            state: string;
            require_mfa: boolean;
            created_at: string;
            expire: string;
        }
        interface InviteRequest {
            inviter: string;
            email: string;
            callback: string;
            state: string;
        }
        interface InviteResult extends InviteItem {
        }
        namespace Delete {
            interface EmailRequest {
                email: string;
            }
            interface IDRequest {
                id: string;
            }
        }
        enum ListOrderBy {
            ID = "id",
            CREATED_AT = "created_at",
            LAST_LOGIN_AT = "last_login_at",
            EMAIL = "email"
        }
        interface ListFilter {
            accepted_eula_id?: string;
            accepted_eula_id__contains?: string[];
            accepted_eula_id__in?: string[];
            created_at?: string;
            created_at__gt?: string;
            created_at__gte?: string;
            created_at__lt?: string;
            created_at__lte?: string;
            disabled?: boolean;
            email?: string;
            email__contains?: string[];
            email__in?: string[];
            id?: string;
            id__contains?: string[];
            id__in?: string[];
            last_login_at?: string;
            last_login_at__gt?: string;
            last_login_at__gte?: string;
            last_login_at__lt?: string;
            last_login_at__lte?: string;
            last_login_ip?: string;
            last_login_ip__contains?: string[];
            last_login_ip__in?: string[];
            last_login_city?: string;
            last_login_city__contains?: string[];
            last_login_city__in?: string[];
            last_login_country?: string;
            last_login_country__contains?: string[];
            last_login_country__in?: string[];
            login_count?: number;
            login_count__gt?: number;
            login_count__gte?: number;
            login_count__lt?: number;
            login_count__lte?: number;
            require_mfa?: boolean;
            scopes?: string[];
            verified?: boolean;
        }
        interface ListRequest {
            filter?: Object | ListFilter;
            last?: string;
            order?: AuthN.ItemOrder;
            order_by?: AuthN.User.ListOrderBy;
            size?: number;
            use_new?: boolean;
        }
        interface ListResult {
            users: UserItem[];
            last?: string;
            count: number;
        }
        namespace Invite {
            enum OrderBy {
                ID = "id",
                CREATED_AT = "created_at",
                TYPE = "type",
                EXPIRE = "expire",
                CALLBACK = "callback",
                STATE = "state",
                EMAIL = "email",
                INVITER = "inviter",
                INVITE_ORG = "invite_org"
            }
            interface DeleteRequest {
                id: string;
            }
            interface ListFilter {
                callback?: string;
                callback__contains?: string[];
                callback__in?: string[];
                created_at?: string;
                created_at__gt?: string;
                created_at__gte?: string;
                created_at__lt?: string;
                created_at__lte?: string;
                email?: string;
                email__contains?: string[];
                email__in?: string[];
                expire?: string;
                expire__gt?: string;
                expire__gte?: string;
                expire__lt?: string;
                expire__lte?: string;
                id?: string;
                id__contains?: string[];
                id__in?: string[];
                invite_org?: string;
                invite_org__contains?: string[];
                invite_org__in?: string[];
                inviter?: string;
                inviter__contains?: string[];
                inviter__in?: string[];
                is_signup?: boolean;
                require_mfa?: boolean;
                state?: string;
                state__contains?: string[];
                state__in?: string[];
            }
            interface ListRequest {
                filter?: Object | ListFilter;
                last?: string;
                order?: ItemOrder;
                order_by?: OrderBy;
                size?: number;
            }
            interface ListResult {
                invites: InviteItem[];
            }
        }
        namespace Authenticators {
            namespace Delete {
                interface IDRequest {
                    id: string;
                    authenticator_id: string;
                }
                interface EmailRequest {
                    email: string;
                    authenticator_id: string;
                }
            }
            interface ListRequest {
                email?: string;
                id?: string;
            }
            interface Authenticator {
                id: string;
                type: string;
                enable: boolean;
                provider?: string;
                rpid: string;
                phase: string;
            }
            interface ListResult {
                authenticators: Authenticator[];
            }
        }
        namespace Profile {
            interface GetResult extends UserItem {
            }
            namespace Get {
                interface EmailRequest {
                    email: string;
                }
                interface IDRequest {
                    id: string;
                }
            }
            namespace Update {
                interface Common {
                    profile: Profile;
                }
                interface EmailRequest extends Common {
                    email: string;
                }
                interface IDRequest extends Common {
                    id: string;
                }
            }
            interface UpdateResult extends UserItem {
            }
        }
        namespace Update {
            interface Options {
                disabled?: boolean;
            }
            interface EmailRequest extends Options {
                email: string;
            }
            interface IDRequest extends Options {
                id: string;
            }
        }
        interface UpdateResult extends UserItem {
        }
    }
}
